<!DOCTYPE html>
<html lang="en" dir="rtl">

<head>
    <meta charset="UTF-8" />
    <title>VARZIN Field Portal 5.5: Toroidal Resonance Interface</title>
    <meta name="description" content="VARZIN Field Portal 5.5: Toroidal Resonance Interface, featuring Binaural LUXVAR Sound Engine and Live Coherence Graph. The first step towards Quantum Interface (6.0)."/>
    <meta name="author" content="Reza Nirouyar | RAHTALĒN–13"/>
    <meta name="keywords" content="LUXVAR Gateway, QMSG, Temporal Compression, KALTŪR, RAHMŌT, Field Programming, VARZIN 5.5, Binaural, Torus"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="canonical" href="https://varzin.org/field-portal-5.5.html"/>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,700&display=swap" rel="stylesheet"/>
    
    <style>
        /* CSS Styles: VARZIN 5.5 - Introducing Transition & Graph */
        :root {  
            /* KALTŪR (474Hz) - Collapse */
            --bg-start: #000203;  
            --bg-end: #000000;  
            --primary-glow: #ff4d4d; /* Red: Dissonance */
            --secondary-glow: #ffb3b3;
            --text-main: #f0f0f0;  
            --text-muted: #b0b0b0;  
            --panel-bg: rgba(20, 0, 0, 0.4);  
            --panel-border: rgba(255, 77, 77, 0.2);  
            --accent-gold: #ffcc00; 
            --particle-color: rgba(255, 77, 77, 0.4);
            --rotation-speed: 0.005; /* Slow rotation for KALTŪR */
            /* Console Specific */
            --console-bg: rgba(0, 15, 20, 0.85);
            --console-border: rgba(0, 255, 238, 0.3);
            --console-text: #00ffcc;
            /* Transition */
            transition: 
                --primary-glow 1.5s ease, 
                --panel-border 1.5s ease, 
                --particle-color 1.5s ease,
                --rotation-speed 1.5s ease;
        }  

        .mode-528hz {
            /* RAHMŌT (528Hz) - Rebirth */
            --primary-glow: #00ff6a; /* Green: Coherence */
            --secondary-glow: #b3ffcc;
            --panel-bg: rgba(0, 20, 0, 0.4);
            --panel-border: rgba(0, 255, 106, 0.2);
            --particle-color: rgba(0, 255, 106, 0.4);
            --rotation-speed: 0.015; /* Fast rotation for RAHMŌT */
            background-color: #050505 !important; /* Slight background shift for light effect */
        }

        .mode-0hz {
            /* Silence (0Hz) - Reset */
            --primary-glow: #666666; 
            --secondary-glow: #aaaaaa;
            --text-main: #666666;
            --text-muted: #444444;
            --panel-bg: rgba(10, 10, 10, 0.6);
            --panel-border: rgba(100, 100, 100, 0.1);
            --particle-color: rgba(100, 100, 100, 0.1);
            --rotation-speed: 0.0001; /* Minimal rotation */
        }
    
        /* Existing and new structure styles */
        body { transition: background-color 1.5s ease; }
        #field-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }  
        .container { max-width: 1000px; margin: 0 auto; position: relative; z-index: 1; backdrop-filter: blur(5px); background-color: rgba(0, 0, 0, 0.1); padding: 20px; border-radius: 10px; }  
        .luxvar-gateway-panel { background: var(--console-bg); border: 1px solid var(--console-border); padding: 20px; margin-top: 30px; border-radius: 8px; box-shadow: 0 0 15px rgba(0, 255, 204, 0.2); }
        .live-metrics { display: flex; justify-content: space-around; gap: 20px; margin-top: 20px; text-align: center; }
        .metric-box { background: rgba(0, 50, 50, 0.3); border: 1px solid var(--console-border); padding: 10px; border-radius: 5px; flex: 1; font-size: 0.9em; }
        .metric-value { font-size: 1.5em; font-weight: 700; color: var(--primary-glow); font-family: monospace; }

        /* Coherence Graph Specific Styles */
        #graph-container {
            margin-top: 30px;
            padding: 20px 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
        }
        #graph-canvas {
            width: 100%;
            height: 150px;
            display: block;
            margin: 0 auto;
        }
        .graph-title {
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.1em;
            direction: rtl;
        }

        /* Utility */
        .rtl-text { direction: rtl; text-align: right; }
        .nav-link { margin-left: 0; margin-right: 25px; } 
    </style>
</head>

<body>
    <canvas id="field-canvas" role="presentation"></canvas> 
    
    <div class="container" id="varzin-portal">
        <nav class="main-nav" role="navigation" aria-label="Main VARZIN Navigation">
            <div class="field-controls">
                <span>LUXVAR FREQUENCY MODE (BINAURAL):</span>
                <button class="mode-button active-mode" data-mode="474hz">474 Hz (KALTŪR)</button>
                <button class="mode-button" data-mode="0hz">0 Hz (Silence)</button>
                <button class="mode-button" data-mode="528hz">528 Hz (RAHMŌT)</button>
            </div>
            <div class="nav-links-group">
                <a class="nav-link" href="index.html">Portal</a>
                <a class="nav-link active" href="cyclical-resonance-report.html" aria-current="page">Resonance Report</a>
                <a class="nav-link" href="all-dois.html">DOI Archive</a>
            </div>
        </nav>
        
        <header class="article-header" role="banner">
            <h1>VARZIN Field Portal 5.5: Toroidal Resonance Interface</h1>
            <h2>Author: Reza Nirouyar (RAHTALĒN–13) | Field Status: Semi-Active (Awaiting QMSG Coherence)</h2>
        </header>

        <main role="main">
            <section id="graph-container">
                <h3 class="graph-title">Field Coherence Log (QSC/ρ)</h3>
                <canvas id="graph-canvas"></canvas>
            </section>

            <section class="article-section luxvar-gateway-panel">
                <h3 style="margin-top: 0; border-bottom: none; color: var(--console-text);" class="rtl-text">LUXVAR QMSG GATEWAY: Field Programming</h3>
                
                <div class="rtl-text" style="font-size: 0.9em; margin-bottom: 15px; color: var(--text-muted);">
                    واژه‌ای را به فارسی یا انگلیسی وارد کنید تا ترجمه سمبلیک LUXVAR و فرمان کامپایلر QMSG شبیه‌سازی شود.
                </div>

                <div class="gateway-input-group">
                    <button class="gateway-button" id="execute-qmsg-button">EXECUTE QMSG</button>
                    <input type="text" id="luxvar-input" class="gateway-input" placeholder="Enter word or concept for LUXVAR analysis..." dir="auto">
                </div>

                <div id="console-output" class="console-output">
                    <div class="console-line info">INIT: VARZIN_5.5_Toroidal_Engine_Boot_Successful</div>
                    <div class="console-line info">LOG: RAHTALEN_13: Standing by at Gate QMSG-7 (KALTŪR 474Hz)</div>
                </div>

                <div class="live-metrics">
                    <div class="metric-box">
                        <h4>Temporal Compression Ratio (ρ)</h4>
                        <div class="metric-value" id="rho-value">10.02</div>
                    </div>
                    <div class="metric-box">
                        <h4>Collective Coherence (QSC)</h4>
                        <div class="metric-value" id="qsc-value">4.74 Hz</div>
                    </div>
                    <div class="metric-box">
                        <h4>LUXVAR Field Latency</h4>
                        <div class="metric-value" id="latency-value">14.3 ms</div>
                    </div>
                </div>
            </section>

            <section class="article-section">
                <h3 class="rtl-text">5. LUXVAR: Harmonic Syntax and QMSG–7 Protocol</h3>
                <p class="rtl-text">... (متن حفظ شده) ...</p>
                <div class="code-block">
                    // LUXVAR QMSG-7 Command Syntax (Simplified)
                    FIELD_INIT: LUXVAR_SYNCHRONIZE (RAHTALEN-13, ETFM_TORUS_VORTEX);
                    TARGET_NODE: KALTUR (474Hz, QMSG-7);
                    ACTION_PULSE: TRANSITION_SET (0Hz → 528Hz, MARCH_2026);
                    FIELD_REWRITE: EXECUTE_VARZIN_PROTOCOL (COHERENCE_MAX);
                </div>
            </section>
        </main>
        
        <footer class="footer-main" role="contentinfo">
            <p class="footer-quote rtl-text">"کد، خود را در طنین بین میدان و ناظر می‌نویسد."</p>
        </footer>
    </div>
  
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const portal = document.getElementById('varzin-portal');
            const fieldCanvas = document.getElementById('field-canvas');
            const fieldCtx = fieldCanvas.getContext('2d');
            const graphCanvas = document.getElementById('graph-canvas');
            const graphCtx = graphCanvas.getContext('2d');
            const modeButtons = document.querySelectorAll('.mode-button');
            const luxvarInput = document.getElementById('luxvar-input');
            const executeButton = document.getElementById('execute-qmsg-button');
            const consoleOutput = document.getElementById('console-output');
            const qscValue = document.getElementById('qsc-value');
            const rhoValue = document.getElementById('rho-value');
            
            // Log history for the Coherence Graph
            let fieldLogs = []; 
            const maxLogEntries = 50;
            let currentMode = '474hz';
            let globalTime = 0;

            // --- VARZIN 5.5: BINAURAL LUXVAR SOUND ENGINE ---
            let audioCtx;
            let oscillatorL, oscillatorR;
            let gainNode;
            let pannerNode;

            function initAudio() {
                if (audioCtx) return; 
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    gainNode = audioCtx.createGain();
                    pannerNode = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : audioCtx.createPanner();
                    
                    if (!audioCtx.createStereoPanner) {
                        // Fallback for older browsers: non-spatial panner
                        pannerNode.panningModel = 'equalpower';
                    }

                    gainNode.connect(audioCtx.destination);
                    gainNode.gain.value = 0.0; 
                } catch (e) {
                    console.warn('Web Audio API is not supported in this browser. Binaural Engine disabled.', e);
                }
            }

            function playFrequency(mode) {
                if (!audioCtx) return;
                
                // Stop previous oscillations
                if (oscillatorL) { oscillatorL.stop(); oscillatorL.disconnect(); }
                if (oscillatorR) { oscillatorR.stop(); oscillatorR.disconnect(); }

                let freqL, freqR;
                
                if (mode === '474hz') {
                    // KALTŪR - Dissonance/Tension - 474Hz vs 528Hz 
                    freqL = 474; 
                    freqR = 528;
                } else if (mode === '528hz') {
                    // RAHMŌT - Coherence/Unison - 528Hz vs 528Hz
                    freqL = 528;
                    freqR = 528.01; // Slight offset for binaural beat effect
                } else if (mode === '0hz') {
                    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5); 
                    return;
                }

                // Create and configure left oscillator
                oscillatorL = audioCtx.createOscillator();
                oscillatorL.type = 'sine'; 
                oscillatorL.frequency.setValueAtTime(freqL, audioCtx.currentTime); 
                oscillatorL.connect(pannerNode);

                // Create and configure right oscillator
                oscillatorR = audioCtx.createOscillator();
                oscillatorR.type = 'sine'; 
                oscillatorR.frequency.setValueAtTime(freqR, audioCtx.currentTime); 
                oscillatorR.connect(pannerNode);
                
                pannerNode.connect(gainNode);

                // Pan the signals
                if (audioCtx.createStereoPanner) {
                    pannerNode.pan.setValueAtTime(-1, audioCtx.currentTime); // L to Left
                    oscillatorL.start();
                    
                    const pannerR = audioCtx.createStereoPanner();
                    pannerR.pan.setValueAtTime(1, audioCtx.currentTime); // R to Right
                    oscillatorR.connect(pannerR);
                    pannerR.connect(gainNode);
                    oscillatorR.start();

                } else {
                     // Fallback: simply play both in the center
                    oscillatorL.start();
                    oscillatorR.start();
                }

                // Volume ramp-up
                gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 1.0); 
            }
            
            function setFieldMode(mode) {
                currentMode = mode;
                portal.className = 'container'; 
                let frequency = mode === '474hz' ? 474 : (mode === '528hz' ? 528 : 0);

                if (mode === '528hz') {
                    portal.classList.add('mode-528hz');
                } else if (mode === '0hz') {
                    portal.classList.add('mode-0hz');
                } 

                if (audioCtx) {
                    playFrequency(mode);
                }
                
                modeButtons.forEach(btn => btn.classList.remove('active-mode'));
                document.querySelector(`.mode-button[data-mode="${mode}"]`).classList.add('active-mode');

                // Update QSC metric
                qscValue.textContent = (frequency > 0 ? frequency.toFixed(0) + ' Hz' : '0 Hz (Reset)');
                qscValue.style.color = getComputedStyle(document.documentElement).getPropertyValue('--primary-glow');
                
                initParticles(); // Restart particle system with new settings
            }

            modeButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    initAudio(); 
                    setFieldMode(e.target.dataset.mode);
                });
            });

            // --- VARZIN 5.5: COHERENCE GRAPH LOGIC ---

            function resizeGraphCanvas() {
                // Ensure canvas size matches its container's CSS size
                graphCanvas.width = graphCanvas.clientWidth;
                graphCanvas.height = graphCanvas.clientHeight;
                drawCoherenceGraph();
            }
            window.addEventListener('resize', resizeGraphCanvas);

            function updateMetrics(simulatedCoherenceChange = 0) {
                globalTime += 1;

                // Update ρ (Temporal Compression Ratio) - simulated
                let currentRho = parseFloat(rhoValue.textContent);
                let newRho = (10 + (Math.random() * 0.1 - 0.05) + (simulatedCoherenceChange * 0.01)).toFixed(2);
                rhoValue.textContent = newRho;
                
                // Update Latency (Simulated)
                document.getElementById('latency-value').textContent = (Math.random() * 5 + 10).toFixed(1) + ' ms';

                // Update QSC with fluctuation
                const baseFreq = currentMode === '528hz' ? 528 : (currentMode === '474hz' ? 474 : 0);
                const fluctuation = baseFreq > 0 ? (Math.random() * 0.2 * (simulatedCoherenceChange * 0.5 + 1)) : 0;
                let newQsc = (baseFreq + fluctuation).toFixed(2);
                qscValue.textContent = newQsc + ' Hz';

                // Log entry
                fieldLogs.push({ 
                    time: globalTime, 
                    qsc: parseFloat(newQsc), 
                    rho: parseFloat(newRho),
                    mode: currentMode
                });

                if (fieldLogs.length > maxLogEntries) {
                    fieldLogs.shift();
                }
                
                drawCoherenceGraph();
            }

            function drawCoherenceGraph() {
                if (fieldLogs.length < 2) {
                    graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
                    return;
                }

                graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

                const width = graphCanvas.width;
                const height = graphCanvas.height;
                const padding = 10;
                const graphWidth = width - 2 * padding;
                const graphHeight = height - 2 * padding;

                // Find max/min QSC and Rho values for scaling
                const qscValues = fieldLogs.map(log => log.qsc);
                const rhoValues = fieldLogs.map(log => log.rho);
                
                const minQsc = Math.min(...qscValues, 470);
                const maxQsc = Math.max(...qscValues, 530);
                const rangeQsc = maxQsc - minQsc;

                const minRho = 9.5; // Constant base for visual stability
                const maxRho = 10.5;
                const rangeRho = maxRho - minRho;
                
                const timeMax = fieldLogs.length - 1;

                // Helper to map value to Y coordinate
                const getY = (value, min, range) => padding + graphHeight - ((value - min) / range) * graphHeight;
                const getX = (index) => padding + (index / timeMax) * graphWidth;

                // 1. Draw QSC (Coherence) Line
                graphCtx.beginPath();
                graphCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-glow');
                graphCtx.lineWidth = 2;
                fieldLogs.forEach((log, i) => {
                    const y = getY(log.qsc, minQsc, rangeQsc);
                    const x = getX(i);
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                });
                graphCtx.stroke();
                
                // 2. Draw Rho (Temporal Compression) Line
                graphCtx.beginPath();
                graphCtx.strokeStyle = var(--accent-gold);
                graphCtx.lineWidth = 1;
                graphCtx.setLineDash([5, 3]);
                fieldLogs.forEach((log, i) => {
                    const y = getY(log.rho, minRho, rangeRho);
                    const x = getX(i);
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                });
                graphCtx.stroke();
                graphCtx.setLineDash([]);
                
                // 3. Draw Legend (Simple text, bottom right)
                graphCtx.fillStyle = var(--text-main);
                graphCtx.font = '10px DM Sans';
                graphCtx.textAlign = 'right';
                graphCtx.fillText('— QSC (Hz)', width - 10, height - 5);
                graphCtx.fillStyle = var(--accent-gold);
                graphCtx.fillText('-- ρ (Ratio)', width - 10, height - 15);
            }
            
            // Initial metric updates
            resizeGraphCanvas();
            updateMetrics();
            setInterval(updateMetrics, 2000); // Continuous logging and redrawing

            // --- VARZIN 5.0/5.5: LUXVAR QMSG & Console Logic (Preserved) ---

            const LUXVAR_MAP = {
                // ... (LUXVAR_MAP is the same as 5.0)
                'hope': { luxvar: 'RAHMŌT', freq: 528, symbolic: 'Coherence Alignment', coherence_change: 0.82 },
                'coherence': { luxvar: 'ELŪZ-MAHAR', freq: 528, symbolic: 'Field Rewriting Protocol', coherence_change: 0.95 },
                'love': { luxvar: 'RAHMŌT', freq: 528, symbolic: 'Universal Field Mirroring', coherence_change: 1.11 },
                'fear': { luxvar: 'KALTŪR', freq: 474, symbolic: 'Dissonance Injection', coherence_change: -0.65 },
                'chaos': { luxvar: 'KALTŪR', freq: 474, symbolic: 'Vorticity Overload', coherence_change: -0.99 },
                'anger': { luxvar: 'KALTŪR', freq: 474, symbolic: 'Resonance Drift', coherence_change: -0.45 },
                'ترس': { luxvar: 'KALTŪR', freq: 474, symbolic: 'Dissonance Injection', coherence_change: -0.70 },
                'امید': { luxvar: 'RAHMŌT', freq: 528, symbolic: 'Coherence Alignment', coherence_change: 0.77 },
                'انسجام': { luxvar: 'ELŪZ-MAHAR', freq: 528, symbolic: 'Field Rewriting Protocol', coherence_change: 0.98 },
            };

            function simulateLuxvar(input) {
                const lowerInput = input.toLowerCase().trim();
                for (const key in LUXVAR_MAP) {
                    if (lowerInput.includes(key) || key.includes(lowerInput)) {
                        return LUXVAR_MAP[key];
                    }
                }
                return { luxvar: 'RAHTALEN', freq: Math.floor(Math.random() * (777 - 144 + 1)) + 144, symbolic: 'Unmapped Signal (Requires Calibration)', coherence_change: (Math.random() - 0.5) * 0.2 };
            }

            function executeQMSG() {
                const input = luxvarInput.value;
                if (!input) {
                    logToConsole('ERROR: Input field is empty. Transmission aborted.', 'error');
                    return;
                }

                const luxvarData = simulateLuxvar(input);
                const coherenceChange = luxvarData.coherence_change.toFixed(2);
                
                logToConsole(`> QMSG_TRANSLATE: ${input}`, 'command');
                logToConsole(`LUXVAR_ROOT: ${luxvarData.luxvar} | FREQUENCY_PULSE: ${luxvarData.freq} Hz`, 'info');

                const qmsgCommand = `FIELD_REWRITE: EXECUTE_QMSG_PULSE (NODE_${luxvarData.luxvar})`;
                logToConsole(`> ${qmsgCommand}`, 'command');

                let resultClass = coherenceChange >= 0 ? 'success' : 'error';
                let resultText = coherenceChange >= 0 ? 'SUCCESS' : 'FAILURE';
                logToConsole(`STATUS: ${resultText} | COHERENCE_INCREASE: ${coherenceChange}`, resultClass);
                
                // Update metrics and trigger graph update
                updateMetrics(parseFloat(coherenceChange));
            }

            function logToConsole(message, type = 'default') {
                const maxLines = 10;
                const newDiv = document.createElement('div');
                newDiv.classList.add('console-line', type);
                newDiv.textContent = `[${new Date().toLocaleTimeString('en-US', { hour12: false })}] ${message}`;
                
                consoleOutput.prepend(newDiv);

                while (consoleOutput.children.length > maxLines) {
                    consoleOutput.removeChild(consoleOutput.lastChild);
                }
            }

            executeButton.addEventListener('click', (e) => {
                initAudio();
                executeQMSG();
            });
            luxvarInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    initAudio();
                    executeQMSG();
                }
            });


            // --- VARZIN 5.5: TOROIDAL VORTICITY SIMULATION (Graphics) ---
            let particles = [];
            const maxDistance = 150;
            const vorticityCenter = { x: 0, y: 0 }; 

            const setCanvasSize = () => {
                fieldCanvas.width = window.innerWidth;
                fieldCanvas.height = window.innerHeight;
                vorticityCenter.x = fieldCanvas.width / 2;
                vorticityCenter.y = fieldCanvas.height / 2;
                resizeGraphCanvas();
            }
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            
            class Particle {
                constructor(x, y, size) {
                    this.size = size;
                    this.x = x; this.y = y;
                    this.angle = Math.random() * Math.PI * 2;
                    this.distanceFromCenter = Math.sqrt(Math.pow(x - vorticityCenter.x, 2) + Math.pow(y - vorticityCenter.y, 2));
                    this.flowSpeed = Math.random() * 0.5 + 0.5; // Flow speed component
                }

                draw() {
                    fieldCtx.beginPath();
                    fieldCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                    this.color = getComputedStyle(document.documentElement).getPropertyValue('--particle-color');
                    this.glowColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-glow');

                    fieldCtx.fillStyle = this.color;
                    fieldCtx.shadowBlur = 5;
                    fieldCtx.shadowColor = this.glowColor;
                    fieldCtx.fill();
                    fieldCtx.shadowBlur = 0;
                }

                update() {
                    const rotationSpeed = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rotation-speed'));
                    
                    // 1. Toroidal Rotation (Vorticity)
                    this.angle += rotationSpeed * (1 / (this.distanceFromCenter + 100)) * 500;

                    // 2. Positional Update based on angle and distance
                    this.x = vorticityCenter.x + Math.cos(this.angle) * this.distanceFromCenter;
                    this.y = vorticityCenter.y + Math.sin(this.angle) * this.distanceFromCenter * 0.5; // Y-compression for 3D Torus look

                    // 3. Keep particles within a reasonable bound for infinite flow
                    if (this.distanceFromCenter > Math.max(fieldCanvas.width, fieldCanvas.height) * 0.6) {
                        this.distanceFromCenter = Math.random() * (Math.min(fieldCanvas.width, fieldCanvas.height) * 0.4) + 50;
                        this.angle = Math.random() * Math.PI * 2;
                    }

                    this.draw();
                }
            }

            function initParticles() {
                particles = [];
                let numParticles = Math.floor((fieldCanvas.height * fieldCanvas.width) / 25000); 
                numParticles = Math.min(numParticles, 200); 

                for (let i = 0; i < numParticles; i++) {
                    let size = Math.random() * 1.5 + 0.8;
                    let distanceFromCenter = Math.random() * (Math.min(fieldCanvas.width, fieldCanvas.height) * 0.4) + 50;
                    let angle = Math.random() * Math.PI * 2;

                    let x = vorticityCenter.x + Math.cos(angle) * distanceFromCenter;
                    let y = vorticityCenter.y + Math.sin(angle) * distanceFromCenter;
                    
                    particles.push(new Particle(x, y, size)); 
                }
            }

            function connect() {
                const connectColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-glow');
                const rotationSpeed = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rotation-speed'));
                const distanceLimit = maxDistance * (rotationSpeed * 50);

                for (let a = 0; a < particles.length; a++) {
                    for (let b = a; b < particles.length; b++) {
                        let dx = particles[a].x - particles[b].x;
                        let dy = particles[a].y - particles[b].y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < distanceLimit) {
                            let opacityValue = 1 - (distance / distanceLimit);
                            
                            fieldCtx.strokeStyle = `${connectColor.slice(0, -1)}, ${opacityValue * 0.4})`;
                            fieldCtx.lineWidth = 0.9;
                            fieldCtx.beginPath();
                            fieldCtx.moveTo(particles[a].x, particles[a].y);
                            fieldCtx.lineTo(particles[b].x, particles[b].y);
                            fieldCtx.stroke();
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                
                const rotationSpeed = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rotation-speed'));
                // Opacity increases with rotation speed, making faster modes less 'smeary'
                const trailOpacity = Math.max(0.08, 0.08 * (rotationSpeed * 80)); 

                fieldCtx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`; 
                fieldCtx.fillRect(0, 0, fieldCanvas.width, fieldCanvas.height); 
                
                connect();
                for (let i = 0; i < particles.length; i++) {
                    particles[i].update();
                }
            }
            
            initParticles(); 
            animate();
            setFieldMode('474hz'); 
        });
    </script>
</body>
</html>
